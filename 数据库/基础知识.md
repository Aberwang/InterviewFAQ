## ACID ##

|属性|说明|
|----|----|
|Atomitity|一个事务的所有操作，要么全部完成，要么全部不完成，不会结束在中间的某个环节。|
|Consistency|一致性属性确保任何事务将数据库从一个有效状态带到另一个有效状态。写入数据库的任何数据必须根据所有定义的规则（包括约束，级联，触发器及其任何组合）有效。这不保证程序员可能想要的所有方式的事务的正确性（那是应用程序代码的责任），但只是任何编程错误不能违背定义好的规则|
|Islation|数据库允许多个并发事务同时对数据进行读写和修改，隔离性可以防止多个并发事务执行时由于交叉执行而导致的数据不一致。事务的隔离级别下文会讲到|
|Durability|事务树立结束后，对数据的修改是永久的，即便系统故障也不会丢失|


## Read phenomenon ##

|问题 | 说明|
|----|-----|
|**Dirty read** |指一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问使用了这个数据|
|**Non-repeatable reads**|指在一个事务内，多次读同一个数据。在这个事务还没有结束时，另外一个事务也访问该同一个数据并作出提交。那么第一个事务中两次读数据可能是不一样的。他与脏读的区别是，脏读读取到了其他事务还未提交的数据，而这里读取的是另一个事务提交的数据|
|**Phantom reads**| 第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部行。同时，第二个事务向表中插入一行新数据。那么，操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。他和不可重复读的区别是，不可重复读查询的都是同一项数据，而幻读针对的是一批数据的整体|


##  Isolation levels ##
|隔离级别 | 解释|
|-------|----|
|Serializable|所有的事务串行化执行，每次读都需要获得表级共享锁，读写相互都会阻塞，这是最强的隔离级别，不会出现上述的三种问题|
|Repeatable Read|在同一个事务中内的多次查询和事务开始时刻都是一致的，该隔离级别消除了不可重复读，但是可能还会出现幻读（可以理解为，可重复读只是保证了针对这一条数据的update事务会被当前可重复读的事务阻塞，而对insert操作的事务则不会被阻塞）|
|Read Committed|只能读取已经提交的数据。即如果两个事务并发，允许读事务过程中发生写事务的提交。这不能保证可重复读|
|Read Uncommitted| 允许脏读，也就是可能读取到其他会话中未提交事务修改的数据|

### Isolation levels & Read phenomenon ###
|Isolation levels|Dirty reads|Non-repeatable reads|Phantoms|
|--|--|--|--|
|Read Uncommitted|may occur|may occur|may occur|
|Read Committed|don't occur|may occur|may occur|
|Repeatable Read|don't occur|don't occur|may occur|
|Serializable|don't occur|don't occur|don't occur|


