# 排序 #

## 插入排序 ##
插入排序与现实生活中打扑克的抓牌的过程是一样的。对于一个新的值A[i],从i-1逐个向前检查，直到遇到比A[i]更小的元素将其插入，当然，需要把目标位置以后的所有项向后移动。代码如下
```java
  public void InsertSort(int[] A) {
        for (int i = 2; i < A.length; i++) {
            int key = A[i];
            int j = i - 1;
            while (j >= 0 && A[j] > key) {
                A[j + 1] = A[j];
                j--;
            }
            A[j + 1] = key;
        }
    }
```
可以发现，插入排序在本身数组排序较好的情况所有的元素都不需要移动，执行过程只是顺序的访问数组元素，所以时间复杂度是O(n)，而在最坏情况下，即所有的元素倒序排列时，由于每一个元素都要移动到已排序数组的顶端，所以时间复杂度为O(n2)


## 归并排序 ##
归并排序基于分治的思想，将一个大的问题分解为多个子问题，分别求解子问题，最后合并子问题得到原问题的解
```java
 public void MergeSort(int[] A, int p, int r) {
        if (p < r) {
            int q = (p + r) / 2;
            MergeSort(A, p, q);
            MergeSort(A, q + 1, r);
            Merge(A, p, q, r);
        }
    }

    public void Merge(int[] A, int p, int q, int r) {
        int n1 = q - p + 1;
        int n2 = r - q;

        int[] left = new int[n1 + 1];
        int[] right = new int[n2 + 1];

        for (int i = 0; i < n1; i++) {
            left[i] = A[p + i];
        }
        left[n1] = Integer.MAX_VALUE;

        for (int j = 0; j < n2; j++) {
            right[j] = A[q + 1 + j];
        }
        right[n2] = Integer.MAX_VALUE;


        int x = 0;
        int y = 0;

        for (int k = p; k <= r; k++) {
            if (left[x] < right[y]) {
                A[k] = left[x];
                x++;
            } else {
                A[k] = right[y];
                y++;
            }
        }
    }
```
以上Merge函数为了能够正常处理边界情况，在每个待Merge的数组的末尾添加了一个无穷大的哨兵。这几假设所有的值都不会大于0x7fffffff
归并排序的时间复杂度是O(nlgn)，由于每一次归并，都需要建立额外的数组，所以空间复杂度也为O(nlgn)

## 堆排序 ##

堆排序基于一种最大堆，最大堆的父节点大于两个子节点。堆的数据存储在一个数组中，通过数组的下标可以计算出父子兄弟节点。所以最大堆一定是平衡二叉树。在介绍堆排序算法之前，我们先看一下如何维持最大堆的性质，因为对于一个给定地数组，我们首先需要将其转化为一个最大堆才能使用堆排序
简单的获取父子节点函数
```java

    public int parent(int i) {
        return (i-1) / 2;
    }

    public int left(int i) {
        return 2 * (i+1) -1;
    }

    public int right(int i) {
        return 2 * (i + 1);
    }

```

维护最大堆性质的思想是，对于给定的i，比较i与其两个子节点，选出最大的值放在i位置，如果发生交换，则递归向下维护交换后的节点最大堆性质
代码如下
```java
 public void MaxHeapify(int[] A, int i) {
        int l = left(i);
        int r = right(i);

        int largest = i;
        if (l < A.length && A[l] > A[i]) {
            largest = l;
        }

        if (r < A.length && A[r] > A[largest]) {
            largest = r;
        }

        if(largest != i){
            int temp = A[i];
            A[i] = A[largest];
            A[largest] = temp;

            MaxHeapify(A, largest);
        }
 }
```
到此，对于任意给定的数组A,其长度为n，我们发现数组中(n/2)-n都是叶节点，所以我们可以不对其进行性质维持。代码如下
```java
    public void BuildMaxHeap(int[] A) {
        for (int i = (A.length-1) / 2; i >= 0; i--) {
            MaxHeapify(A, i);
        }
    }
```
堆排序算法的思想是将堆中的最后一个元素与第一个元素交换，这样最大的元素位与堆的尾部。针对第一个元素维护最大堆的性质，依次循环。
代码如下
```java
    public void HeapSort(int[] A){
        BuildMaxHeap(A);
        for(int i = A.length-1; i>0; i--){
            int temp = A[i];
            A[i] = A[0];
            A[0] = temp;
            MaxHeapify(A,0, i);
        }
    }
```
每次调用MaxHeapify的复杂度是O(lgn), 共有n个元素所以复杂度为O(nlgn)。而建堆的过程是对n/2个元素依次调用MaxHeapify，所以其时间复杂度也是O(nlgn)

### 快速排序 ###
快速排序的基本思想是选取数组中的一个值x，将所有大于x的项移动到x右边，所有小于x的项移动到x的左边。然后对于两边的两个子数组递归的执行此步骤。代码如下
```java
public void quickSort(int[] A, int left, int right) {
        if (left >= right) {
            return;
        }

        int midIndex = (left + right) / 2;
        int pivot = A[midIndex];

        int i = left;
        int j = right;

        while (i <= j) {
            while (A[i] < pivot) {
                i++;
            }
            while (A[j] > pivot) {
                j--;
            }

            if (i <= j) {
                int temp = A[i];
                A[i] = A[j];
                A[j] = temp;
                i++;
                j--;
            }
        }

        quickSort(A, left, j);
        quickSort(A, i, right);
    }
```


