# Java内存模型 #
### 1、程序计数器 ###
>程序计数器是当前线程所执行的字节码的行号指示器，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。
### 2、虚拟机栈 ###
>每个方法在执行的过程中都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出站的过程
### 3、本地方法栈 ###
>本地方法栈与虚拟机栈类似，只不过后者为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。
### 4、堆 ###
>唯一的目的是存储对象的实例
### 5、方法区 ###
>与堆一样，是各个线程共享的内存区域，他用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。编译器生成的各种字面量和符号引用存储在类加载后进入方法区的运行时常量池中。


# 垃圾收集机制 #
引用计数法难以处理循环引用的对象的垃圾回收问题，java C#等语言使用可达性分析来判断对象是否存活。基本思想是通过一系列的成为GC roots的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，有如果从GC root到这个对象不可达，则证明此对象是不可用的。GC Root对象包含以下几种
>
- 虚拟机栈中的引用对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中引用的对象

具体的收集方法有：
>
1. 标记-清楚算法
2. 复制算法  Eden Survivor 8:1:1
3. 标记整理算法

内存分配策略:
>
1. 对象优先分配在Eden中
2. 大对象直接进入老年代
3. 长期存活的对象将进入老年代（经历一次GC仍存活则年龄加一）


# 类加载机制 #
类加载分为五个阶段
### 加载 ###
>
1. 通过一个类的完全限定名蔡获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.long.Class对象，作为方法区这个类的各种数据的访问入口
### 验证 ###
>
1. 文件格式的验证， 如是否以魔数开头，常量池中的常量是否有不被支持的类型等
2. 元数据验证，如这个类是否有父类，是否实现了父类或接口中要求实现的所有方法等
3. 字节码验证，比如抱枕跳转指令不会跳转到方法体以外的字节码指令上。保证方法体中的类型转换是有效的
4. 符号引用验证，如符号引用的类，字段，方法的访问性是否可以被当前类访问

### 准备 ###
>
本阶段为类变量分配内存并设置类变量的初始值，注意这里指的是类变量

### 解析 ###
>
解析阶段是讲虚拟机常量池内的符号引用替换为直接引用的过程，所谓符号引用即以一组符号描述所引用的目标，如一个方法的名称，类名等。解析的过程是将这些符号解析为直接指向目标的指针，相对偏移量或者一个能间接定位到目标的句柄。
>
1. 类或者接口的解析
2. 字段解析
3. 类方法解析
4. 接口方法解析

### 初始化 ###
><clinit>由编译器自动收集类中所有变量的赋值动作和静态语句块中的语句合并产生。
>虚拟机保证子类的<clinit>方法执行前会先执行父类的<clinit>方法，因此虚拟机中第一个被执行的<clinit>方法的类一定是Object

## 类加载器 ##
#### 双亲委派模型， ####
>其要求除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器，这里的父类加载器之间的父子关系一般不会以集成的关系来实现，而都是使用组合关系来复用父加载器。其工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，自加载器才会尝试去加载。
